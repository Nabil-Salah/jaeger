// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: query.proto

package api_v2

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"

	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
	jaegerIdlModel "github.com/jaegertracing/jaeger-idl/proto-gen/api_v2"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetTraceRequest = jaegerIdlModel.GetTraceRequest




var xxx_messageInfo_GetTraceRequest proto.InternalMessageInfo



type SpansResponseChunk = jaegerIdlModel.SpansResponseChunk




var xxx_messageInfo_SpansResponseChunk proto.InternalMessageInfo



type ArchiveTraceRequest = jaegerIdlModel.ArchiveTraceRequest



var xxx_messageInfo_ArchiveTraceRequest proto.InternalMessageInfo



type ArchiveTraceResponse = jaegerIdlModel.ArchiveTraceResponse




var xxx_messageInfo_ArchiveTraceResponse proto.InternalMessageInfo

// Query parameters to find traces. Except for num_traces, all fields should be treated
// as forming a conjunction, e.g., "service_name='X' AND operation_name='Y' AND ...".
// All fields are matched against individual spans, not at the trace level.
// The returned results contain traces where at least one span matches the conditions.
// When num_traces results in fewer traces returned, there is no required ordering.
//
// Note: num_traces should restrict the number of traces returned, but not all backends
// interpret it this way. For instance, in Cassandra this limits the number of _spans_
// that match the conditions, and the resulting number of traces can be less.
//
// Note: some storage implementations do not guarantee the correct implementation of all parameters.
//
type TraceQueryParameters = jaegerIdlModel.TraceQueryParameters




var xxx_messageInfo_TraceQueryParameters proto.InternalMessageInfo



type FindTracesRequest = jaegerIdlModel.FindTracesRequest



var xxx_messageInfo_FindTracesRequest proto.InternalMessageInfo


type GetServicesRequest = jaegerIdlModel.GetServicesRequest




var xxx_messageInfo_GetServicesRequest proto.InternalMessageInfo

type GetServicesResponse = jaegerIdlModel.GetServicesResponse




type GetOperationsRequest = jaegerIdlModel.GetOperationsRequest



var xxx_messageInfo_GetOperationsRequest proto.InternalMessageInfo



type Operation = jaegerIdlModel.Operation



var xxx_messageInfo_Operation proto.InternalMessageInfo



type GetOperationsResponse = jaegerIdlModel.GetOperationsResponse



var xxx_messageInfo_GetOperationsResponse proto.InternalMessageInfo



type GetDependenciesRequest = jaegerIdlModel.GetDependenciesRequest



var xxx_messageInfo_GetDependenciesRequest proto.InternalMessageInfo



type GetDependenciesResponse = jaegerIdlModel.GetDependenciesResponse



var xxx_messageInfo_GetDependenciesResponse proto.InternalMessageInfo



func init() {
	proto.RegisterType((*GetTraceRequest)(nil), "jaeger.api_v2.GetTraceRequest")
	proto.RegisterType((*SpansResponseChunk)(nil), "jaeger.api_v2.SpansResponseChunk")
	proto.RegisterType((*ArchiveTraceRequest)(nil), "jaeger.api_v2.ArchiveTraceRequest")
	proto.RegisterType((*ArchiveTraceResponse)(nil), "jaeger.api_v2.ArchiveTraceResponse")
	proto.RegisterType((*TraceQueryParameters)(nil), "jaeger.api_v2.TraceQueryParameters")
	proto.RegisterMapType((map[string]string)(nil), "jaeger.api_v2.TraceQueryParameters.TagsEntry")
	proto.RegisterType((*FindTracesRequest)(nil), "jaeger.api_v2.FindTracesRequest")
	proto.RegisterType((*GetServicesRequest)(nil), "jaeger.api_v2.GetServicesRequest")
	proto.RegisterType((*GetServicesResponse)(nil), "jaeger.api_v2.GetServicesResponse")
	proto.RegisterType((*GetOperationsRequest)(nil), "jaeger.api_v2.GetOperationsRequest")
	proto.RegisterType((*Operation)(nil), "jaeger.api_v2.Operation")
	proto.RegisterType((*GetOperationsResponse)(nil), "jaeger.api_v2.GetOperationsResponse")
	proto.RegisterType((*GetDependenciesRequest)(nil), "jaeger.api_v2.GetDependenciesRequest")
	proto.RegisterType((*GetDependenciesResponse)(nil), "jaeger.api_v2.GetDependenciesResponse")
}

func init() { proto.RegisterFile("query.proto", fileDescriptor_5c6ac9b241082464) }

var fileDescriptor_5c6ac9b241082464 = []byte{
	// 995 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x67, 0x1d, 0x3b, 0xb6, 0xdf, 0xda, 0x2d, 0x1d, 0x3b, 0xed, 0xb2, 0xa5, 0xb6, 0xb3, 0xa1,
	0x95, 0x85, 0x94, 0xdd, 0x62, 0x0e, 0x94, 0x0a, 0x09, 0x9a, 0xa6, 0xb5, 0x0a, 0xb4, 0xc0, 0x36,
	0x27, 0x38, 0x58, 0x13, 0xef, 0xb0, 0x5e, 0x1c, 0xcf, 0xba, 0xbb, 0xe3, 0x24, 0x16, 0xe2, 0xc2,
	0x27, 0x40, 0xea, 0x85, 0x13, 0xdf, 0x80, 0xaf, 0x81, 0x72, 0x44, 0xe2, 0xc6, 0x21, 0xa0, 0x88,
	0x0f, 0xc1, 0x11, 0xcd, 0x9f, 0x75, 0x76, 0xd7, 0x51, 0x08, 0xe1, 0xd8, 0x93, 0x77, 0xde, 0xbc,
	0xf7, 0x7b, 0x7f, 0x7f, 0x6f, 0x0c, 0xfa, 0x8b, 0x19, 0x89, 0xe6, 0xf6, 0x34, 0x0a, 0x59, 0x88,
	0xea, 0xdf, 0x60, 0xe2, 0x93, 0xc8, 0xc6, 0xd3, 0x60, 0xb0, 0xdf, 0x33, 0xf5, 0x49, 0xe8, 0x91,
	0x3d, 0x79, 0x67, 0x36, 0xfd, 0xd0, 0x0f, 0xc5, 0xa7, 0xc3, 0xbf, 0x94, 0xf4, 0x4d, 0x3f, 0x0c,
	0xfd, 0x3d, 0xe2, 0xe0, 0x69, 0xe0, 0x60, 0x4a, 0x43, 0x86, 0x59, 0x10, 0xd2, 0x58, 0xdd, 0xb6,
	0xd5, 0xad, 0x38, 0xed, 0xce, 0xbe, 0x76, 0x58, 0x30, 0x21, 0x31, 0xc3, 0x93, 0xa9, 0x52, 0x68,
	0xe5, 0x15, 0xbc, 0x59, 0x24, 0x10, 0xe4, 0xbd, 0xf5, 0xb2, 0x00, 0x57, 0xfb, 0x84, 0xed, 0x44,
	0x78, 0x48, 0x5c, 0xf2, 0x62, 0x46, 0x62, 0x86, 0xbe, 0x82, 0x0a, 0xe3, 0xe7, 0x41, 0xe0, 0x19,
	0x5a, 0x47, 0xeb, 0xd6, 0xb6, 0x3e, 0x3a, 0x3a, 0x6e, 0xbf, 0xf6, 0xfb, 0x71, 0x7b, 0xd3, 0x0f,
	0xd8, 0x68, 0xb6, 0x6b, 0x0f, 0xc3, 0x89, 0x23, 0x33, 0xe1, 0x8a, 0x01, 0xf5, 0xd5, 0xc9, 0x91,
	0xf9, 0x08, 0xb4, 0x27, 0xdb, 0x27, 0xc7, 0xed, 0xb2, 0xfa, 0x74, 0xcb, 0x02, 0xf1, 0x89, 0x87,
	0x1e, 0x02, 0xc4, 0x0c, 0x47, 0x6c, 0xc0, 0x23, 0x35, 0x0a, 0x1d, 0xad, 0xab, 0xf7, 0x4c, 0x5b,
	0x46, 0x69, 0x27, 0x51, 0xda, 0x3b, 0x49, 0x1a, 0x5b, 0x15, 0xee, 0xfa, 0x87, 0x3f, 0xda, 0x9a,
	0x5b, 0x15, 0x76, 0xfc, 0x06, 0x7d, 0x08, 0x15, 0x42, 0x3d, 0x09, 0xb1, 0xf2, 0x1f, 0x20, 0xca,
	0x84, 0x7a, 0x02, 0xe0, 0x16, 0x40, 0x84, 0x0f, 0x06, 0x22, 0xa8, 0xd8, 0x28, 0x76, 0xb4, 0x6e,
	0xc5, 0xad, 0x46, 0xf8, 0x40, 0x84, 0x1b, 0x5b, 0x8f, 0x00, 0x3d, 0x9f, 0x62, 0x1a, 0xbb, 0x24,
	0x9e, 0x86, 0x34, 0x26, 0x0f, 0x47, 0x33, 0x3a, 0x46, 0x0e, 0x94, 0x62, 0x2e, 0x35, 0xb4, 0xce,
	0x4a, 0x57, 0xef, 0x35, 0xec, 0x4c, 0x33, 0x6d, 0x6e, 0xb1, 0x55, 0xe4, 0xbe, 0x5c, 0xa9, 0x67,
	0xfd, 0xad, 0x41, 0xe3, 0x41, 0x34, 0x1c, 0x05, 0xfb, 0xe4, 0x15, 0x2b, 0xb0, 0x75, 0x1d, 0x9a,
	0xd9, 0xcc, 0x65, 0x21, 0xad, 0x5f, 0x8a, 0xd0, 0x14, 0x92, 0x2f, 0x38, 0x2b, 0x3e, 0xc7, 0x11,
	0x9e, 0x10, 0x46, 0xa2, 0x18, 0xad, 0x43, 0x2d, 0x26, 0xd1, 0x7e, 0x30, 0x24, 0x03, 0x8a, 0x27,
	0x44, 0xd4, 0xa5, 0xea, 0xea, 0x4a, 0xf6, 0x0c, 0x4f, 0x08, 0xba, 0x0d, 0x57, 0xc2, 0x29, 0x91,
	0xe3, 0x2b, 0x95, 0x0a, 0x42, 0xa9, 0xbe, 0x90, 0x0a, 0xb5, 0x07, 0x50, 0x64, 0xd8, 0x8f, 0x8d,
	0x15, 0xd1, 0xa5, 0xcd, 0x5c, 0x97, 0xce, 0x72, 0x6e, 0xef, 0x60, 0x3f, 0x7e, 0x44, 0x59, 0x34,
	0x77, 0x85, 0x29, 0xfa, 0x18, 0xae, 0x9c, 0xd6, 0x70, 0x30, 0x09, 0xa8, 0x18, 0x91, 0x8b, 0x16,
	0xa1, 0xb6, 0xa8, 0xe3, 0xd3, 0x80, 0xe6, 0xb1, 0xf0, 0xa1, 0x51, 0xba, 0x1c, 0x16, 0x3e, 0x44,
	0x8f, 0xa1, 0x96, 0xf0, 0x57, 0x44, 0xb5, 0x2a, 0x90, 0xde, 0x58, 0x42, 0xda, 0x56, 0x4a, 0x12,
	0xe8, 0x47, 0x0e, 0xa4, 0x27, 0x86, 0x3c, 0xa6, 0x0c, 0x0e, 0x3e, 0x34, 0xca, 0x97, 0xc1, 0xc1,
	0x87, 0xb2, 0x69, 0x38, 0x1a, 0x8e, 0x06, 0x1e, 0x99, 0xb2, 0x91, 0x51, 0xe9, 0x68, 0xdd, 0x12,
	0x6f, 0x1a, 0x97, 0x6d, 0x73, 0x51, 0x8e, 0x69, 0xd5, 0x1c, 0xd3, 0xcc, 0xf7, 0xa0, 0xba, 0x28,
	0x3e, 0x7a, 0x1d, 0x56, 0xc6, 0x64, 0xae, 0x5a, 0xcf, 0x3f, 0x51, 0x13, 0x4a, 0xfb, 0x78, 0x6f,
	0x96, 0x74, 0x5a, 0x1e, 0xee, 0x17, 0xee, 0x69, 0xd6, 0x33, 0xb8, 0xf6, 0x38, 0xa0, 0x9e, 0x84,
	0x49, 0x88, 0xf5, 0x3e, 0x94, 0xc4, 0xb6, 0x15, 0x10, 0x7a, 0x6f, 0xe3, 0x02, 0xbd, 0x77, 0xa5,
	0x85, 0xd5, 0x04, 0xd4, 0x27, 0xec, 0xb9, 0x1c, 0xb7, 0x04, 0xd0, 0x7a, 0x07, 0x1a, 0x19, 0xa9,
	0x9c, 0x62, 0x64, 0x42, 0x45, 0x0d, 0xa6, 0x5c, 0x06, 0x55, 0x77, 0x71, 0xb6, 0x9e, 0x42, 0xb3,
	0x4f, 0xd8, 0x67, 0xc9, 0x48, 0x2e, 0x62, 0x33, 0xa0, 0xac, 0x74, 0x54, 0x82, 0xc9, 0x11, 0xdd,
	0x84, 0x2a, 0xdf, 0x17, 0x83, 0x71, 0x40, 0x3d, 0x95, 0x68, 0x85, 0x0b, 0x3e, 0x09, 0xa8, 0x67,
	0x7d, 0x00, 0xd5, 0x05, 0x16, 0x42, 0x50, 0x4c, 0x91, 0x43, 0x7c, 0x9f, 0x6f, 0x3d, 0x87, 0xb5,
	0x5c, 0x30, 0x2a, 0x83, 0x3b, 0x29, 0x2e, 0x71, 0xd6, 0x24, 0x79, 0xe4, 0xa4, 0xe8, 0x1e, 0xc0,
	0x42, 0x12, 0x1b, 0x05, 0x41, 0x29, 0x23, 0x57, 0xd6, 0x05, 0xbc, 0x9b, 0xd2, 0xb5, 0x7e, 0xd2,
	0xe0, 0x7a, 0x9f, 0xb0, 0x6d, 0x32, 0x25, 0xd4, 0x23, 0x74, 0x18, 0x9c, 0xb6, 0x29, 0xbb, 0xa2,
	0xb4, 0xff, 0xbf, 0xa2, 0x0a, 0x97, 0x59, 0x51, 0xbb, 0x70, 0x63, 0x29, 0x3e, 0x55, 0x9d, 0x3e,
	0xd4, 0xbc, 0x94, 0x5c, 0x2d, 0xfc, 0x5b, 0xb9, 0xbc, 0x17, 0xa6, 0xf3, 0x4f, 0x03, 0x3a, 0x56,
	0xab, 0x3f, 0x63, 0xd8, 0xfb, 0xb9, 0x04, 0x35, 0x31, 0x70, 0x6a, 0x84, 0xd0, 0x18, 0x2a, 0xc9,
	0x73, 0x8b, 0x5a, 0x39, 0xbc, 0xdc, 0x3b, 0x6c, 0xae, 0x9f, 0xf1, 0xc0, 0x64, 0x9f, 0x24, 0xcb,
	0xfc, 0xfe, 0xb7, 0xbf, 0x5e, 0x16, 0x9a, 0x08, 0x39, 0x92, 0x60, 0xce, 0xb7, 0xc9, 0xc3, 0xf2,
	0xdd, 0x5d, 0x0d, 0x31, 0xa8, 0xa5, 0x97, 0x30, 0xb2, 0x72, 0x80, 0x67, 0xbc, 0x4d, 0xe6, 0xc6,
	0xb9, 0x3a, 0x6a, 0x8b, 0xdf, 0x14, 0x6e, 0xd7, 0xac, 0x86, 0x83, 0xe5, 0x75, 0xca, 0x2f, 0xf2,
	0x01, 0x4e, 0x99, 0x89, 0x3a, 0x39, 0xbc, 0x25, 0xd2, 0x5e, 0x24, 0x4d, 0x24, 0xfc, 0xd5, 0xac,
	0xb2, 0x23, 0x57, 0xcb, 0x7d, 0xed, 0xed, 0xbb, 0x1a, 0xf2, 0x41, 0x4f, 0x91, 0x13, 0xad, 0x2f,
	0x97, 0x33, 0x47, 0x67, 0xd3, 0x3a, 0x4f, 0x45, 0xe5, 0x76, 0x4d, 0xf8, 0xd2, 0x51, 0xd5, 0x49,
	0x28, 0x8d, 0x42, 0xa8, 0x67, 0x58, 0x84, 0x36, 0x96, 0x71, 0x96, 0x08, 0x6f, 0xbe, 0x75, 0xbe,
	0x92, 0x72, 0xd7, 0x10, 0xee, 0xea, 0x48, 0x77, 0x4e, 0xb9, 0x83, 0x0e, 0xc4, 0x9f, 0xb2, 0xf4,
	0x68, 0xa2, 0xdb, 0xcb, 0x68, 0x67, 0x50, 0xcb, 0xbc, 0xf3, 0x6f, 0x6a, 0xca, 0xed, 0x9a, 0x70,
	0x7b, 0x15, 0xd5, 0x9d, 0xf4, 0xbc, 0x6e, 0x6d, 0x1e, 0x9d, 0xb4, 0xb4, 0x5f, 0x4f, 0x5a, 0xda,
	0x9f, 0x27, 0x2d, 0x0d, 0x6e, 0x04, 0xa1, 0x9d, 0xf9, 0x17, 0xa2, 0x50, 0xbf, 0x5c, 0x95, 0xbf,
	0xbb, 0xab, 0x82, 0x69, 0xef, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x43, 0x45, 0x1e, 0x73, 0xe4,
	0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient = jaegerIdlModel.QueryServiceClient


type queryServiceClient struct {
	cc *grpc.ClientConn
}

func NewQueryServiceClient(cc *grpc.ClientConn) QueryServiceClient {
	return &queryServiceClient{cc}
}

func (c *queryServiceClient) GetTrace(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (QueryService_GetTraceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[0], "/jaeger.api_v2.QueryService/GetTrace", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceGetTraceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_GetTraceClient = jaegerIdlModel.QueryService_GetTraceClient

type queryServiceGetTraceClient struct {
	grpc.ClientStream
}

func (x *queryServiceGetTraceClient) Recv() (*SpansResponseChunk, error) {
	m := new(SpansResponseChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) ArchiveTrace(ctx context.Context, in *ArchiveTraceRequest, opts ...grpc.CallOption) (*ArchiveTraceResponse, error) {
	out := new(ArchiveTraceResponse)
	err := c.cc.Invoke(ctx, "/jaeger.api_v2.QueryService/ArchiveTrace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) FindTraces(ctx context.Context, in *FindTracesRequest, opts ...grpc.CallOption) (QueryService_FindTracesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_QueryService_serviceDesc.Streams[1], "/jaeger.api_v2.QueryService/FindTraces", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryServiceFindTracesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type QueryService_FindTracesClient = jaegerIdlModel.QueryService_FindTracesClient

type queryServiceFindTracesClient struct {
	grpc.ClientStream
}

func (x *queryServiceFindTracesClient) Recv() (*SpansResponseChunk, error) {
	m := new(SpansResponseChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryServiceClient) GetServices(ctx context.Context, in *GetServicesRequest, opts ...grpc.CallOption) (*GetServicesResponse, error) {
	out := new(GetServicesResponse)
	err := c.cc.Invoke(ctx, "/jaeger.api_v2.QueryService/GetServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) GetOperations(ctx context.Context, in *GetOperationsRequest, opts ...grpc.CallOption) (*GetOperationsResponse, error) {
	out := new(GetOperationsResponse)
	err := c.cc.Invoke(ctx, "/jaeger.api_v2.QueryService/GetOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryServiceClient) GetDependencies(ctx context.Context, in *GetDependenciesRequest, opts ...grpc.CallOption) (*GetDependenciesResponse, error) {
	out := new(GetDependenciesResponse)
	err := c.cc.Invoke(ctx, "/jaeger.api_v2.QueryService/GetDependencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer = jaegerIdlModel.QueryServiceServer


// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer = jaegerIdlModel.UnimplementedQueryServiceServer




func RegisterQueryServiceServer(s *grpc.Server, srv QueryServiceServer) {
	jaegerIdlModel.RegisterQueryServiceServer(s,srv)
}

func _QueryService_GetTrace_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTraceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).GetTrace(m, &queryServiceGetTraceServer{stream})
}

type QueryService_GetTraceServer = jaegerIdlModel.QueryService_GetTraceServer


type queryServiceGetTraceServer struct {
	grpc.ServerStream
}

func (x *queryServiceGetTraceServer) Send(m *SpansResponseChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_ArchiveTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).ArchiveTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.api_v2.QueryService/ArchiveTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).ArchiveTrace(ctx, req.(*ArchiveTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_FindTraces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FindTracesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServiceServer).FindTraces(m, &queryServiceFindTracesServer{stream})
}

type QueryService_FindTracesServer = jaegerIdlModel.QueryService_FindTracesServer

type queryServiceFindTracesServer struct {
	grpc.ServerStream
}

func (x *queryServiceFindTracesServer) Send(m *SpansResponseChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _QueryService_GetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).GetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.api_v2.QueryService/GetServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).GetServices(ctx, req.(*GetServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_GetOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).GetOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.api_v2.QueryService/GetOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).GetOperations(ctx, req.(*GetOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryService_GetDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDependenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServiceServer).GetDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.api_v2.QueryService/GetDependencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServiceServer).GetDependencies(ctx, req.(*GetDependenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.api_v2.QueryService",
	HandlerType: (*QueryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ArchiveTrace",
			Handler:    _QueryService_ArchiveTrace_Handler,
		},
		{
			MethodName: "GetServices",
			Handler:    _QueryService_GetServices_Handler,
		},
		{
			MethodName: "GetOperations",
			Handler:    _QueryService_GetOperations_Handler,
		},
		{
			MethodName: "GetDependencies",
			Handler:    _QueryService_GetDependencies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTrace",
			Handler:       _QueryService_GetTrace_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindTraces",
			Handler:       _QueryService_FindTraces_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "query.proto",
}



func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}


func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = jaegerIdlModel.ErrInvalidLengthQuery
	ErrIntOverflowQuery          = jaegerIdlModel.ErrIntOverflowQuery
	ErrUnexpectedEndOfGroupQuery = jaegerIdlModel.ErrUnexpectedEndOfGroupQuery
)
